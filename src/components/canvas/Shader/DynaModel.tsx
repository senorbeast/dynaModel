/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three'
import React, { useMemo, useRef, useState } from 'react'
import { Merged, Stars, useGLTF } from '@react-three/drei'
import { GLTF } from 'three-stdlib'

type GLTFResult = GLTF & {
  nodes: {
    Camera_Module_1: THREE.Mesh
    Camera_Module_2: THREE.Mesh
    Default_Module: THREE.Mesh
    USB_Port: THREE.Mesh
    USB: THREE.Object3D
  }
  materials: {
    Glass_Material: THREE.MeshStandardMaterial
    Plastic_Material: THREE.MeshStandardMaterial
    Wood_Material: THREE.MeshStandardMaterial
    Metal_Material: THREE.MeshStandardMaterial
  }
}

const DynaModel = ({
  mtype,
  ...props
}: JSX.IntrinsicElements['group'] & { mtype: string }) => {
  const group = useRef<THREE.Group>()

  // Parse and Cache glb file
  const Module_GEO = useGLTF(`/${mtype}_Module_GEO.glb`) as GLTFResult
  const USB_Port_GEO = useGLTF(`/USB_Port_GEO.glb`) as GLTFResult
  console.log(USB_Port_GEO)
  const { materials } = useGLTF(`/ALL_MATERIALS.glb`) as GLTFResult
  // const [GeoMat, setGeoMat] = useState<THREE.MeshStandardMaterial>()

  // Object.entries(mcamera.nodes).forEach((node) => {
  //   if (node[1].type === 'Mesh') {
  //     console.log(node[1])
  //     // setGeoMat((prev) => [...prev, node])
  //     GeoMat.current.push(node[1])
  //   }
  // })

  // Filter out Meshes
  const meshes_Module: THREE.Mesh[] = Object.values(Module_GEO.nodes).filter(
    (value) => value.type === 'Mesh'
  )

  const meshes_USB_Port: THREE.Mesh[] = Object.values(
    USB_Port_GEO.nodes
  ).filter((value) => value.type === 'Mesh')

  // console.log(mcamera.materials, mcamera.nodes)
  // console.log(meshes)
  // console.log(mcamera.materials)

  return (
    <>
      {/* Module */}
      {meshes_Module.map((mesh) => (
        <mesh
          key={mesh.name}
          geometry={mesh.geometry}
          material={materials[mesh.material.name]} // I plan to load materials in separate glb files, so I am refering like this.
        ></mesh>
      ))}

      <group position={Module_GEO.nodes.USB.position}>
        {/* USB Port */}
        {meshes_USB_Port.map((mesh) => (
          <mesh
            key={mesh.name}
            geometry={mesh.geometry}
            material={materials[mesh.material.name]} // I plan to load materials in separate glb files, so I am refering like this.
          ></mesh>
        ))}
      </group>
    </>
  )
}

export default DynaModel

/**
 * Dynamic Models
 *
 * 3D Meshes
 *
 * mesh = geo + mat  --> .glb     ~2-5mb
 *
 * 30 Modules = 30 meshes          ~60-150 mb
 *
 * But,
 *
 * Many modules may be have same geometry,
 * and same set of materials.
 *
 * Makes sense to load a set of generic geometries and standard materials
 * and use their instances for different meshes
 *
 * Module Mesh -> we can mix and match
 * Module Mesh -> load geometry and material separately
 *
 * 30 Geometries, 10 Materials - approx         ~ 50mb
 *
 * So, loading materials, geometries individually for each module/hub.
 *
 */

/**
 *
 * Json for modules
 *
 */
// type Mods = {
//   type: string
//   gltfObject: GLTFResult
// }

// const GeoMatList: Mods[] = [
//   {
//     type: 'camera',
//     gltfObject: mcamera,
//   },
//   {
//     type: 'glassM',
//     gltfObject: GlassM,
//   },
//
// ]
